-------------------------------------------------------------------------------------------------------------
Igualdades entre MODI_raw_F1 y MODI_raw_F2 (archivos cpp y sus respectivos hpp):

	1.	CalcFunctions.cpp 				iguales
	2.	Retina.cpp 						iguales	
	3.	SimFiles.cpp					iguales
	4.	RetinaFilter.cpp				iguales
	5.	Champion.cpp					iguales

Diferencias entre MODI_raw_F1 y MODI_raw_F2:

	1.	Fitness.cpp

		a)		Para el miembro función Fitness::measuringValues hay un parámetro adicional en MODI_raw_F2 que registra las colisiones. En caso que el robot está
			 	chocando se castiga eliminando un valor del vector de posición y cola y no agregando los datos actuales.	

	2.	RIAR.cpp
		
		a) 		Agrega detección de coliciones en el chasis y en las ruedas del robot. 
				La clase CollisionObject está definida en RobotLib

-------------------------------------------------------------------------------------------------------------
Igualdades entre MODI_raw_F1 y MODI_raw_F3 (archivos cpp y sus respectivos hpp):

	1.	CalcFunctions.cpp 				iguales
	2.	Retina.cpp						iguales
	3.	SimFiles.cpp					iguales
	4. 	RIAR.cpp						iguales (cambia una forma de escribir una condición con un flag pero hace exactamente lo mismo)
	5.	Champion.cpp					iguales
	6. 	RetinaFilter.cpp				iguales

Diferencias entre MODI_raw_F1 y MODI_raw_F3:
	
	1.	Fitness.cpp

		a)		Para el miembro función Fitness::measuringValues no se agrega el parámetro "tail" por lo que no se calcula si el robot está yendo en reversa o no
				en el momento de medición.

		b)		Para el miembro función Fitness::calculateFitness() en F1 se calcula que las ruedas por separado tengan cierta desviación estándar de cambio de 
				velocidad por separado,	en cambio en F3 lo importante es que la diferencia de velocidades entre ambas ruedas presenten una desviación estandar no 
				menor a cierto rango.

		c)		Para el miembro función Fitness::calculateFitness() la distancia para calcular el fitness en F1 se toma con respecto a todas las mediciones efectuadas, 
				pero en F3 sólo se considera el punto inicial y el punto final de la simulación.

		d) 		Para el miembro función Fitness::resetPopulationValues() no se limpia el parámetro tail en F3 ya que ese parámetro no existe

-------------------------------------------------------------------------------------------------------------
Igualdades entre MODI_raw_F1 y MODI_retina_F1 (archivos cpp y sus respectivos hpp):

	1.	CalcFunctions.cpp 				iguales
	2.	Fitness.cpp						iguales
	3.	Retina.cpp						iguales
	4.	SimFiles.cpp					iguales
	5.	RetinaFilter.cpp				iguales

Diferencias entre MODI_raw_F1 y MODI_retina_F1:

	1.	RIAR.cpp

		a)		Se crea un objeto del tipo Retina y se obtiene una imagen procesada por ese objeto para pasarlo como parámetro a la red de aprendizaje.

	2.	Champion.cpp

		a)		Se crea un objeto del tipo Retina y se obtiene una imagen procesada por ese objeto para pasarlo como parámetro a la red de aprendizaje.

-------------------------------------------------------------------------------------------------------------
Igualdades entre MODI_raw_F2 y MODI_retina_F2 (archivos cpp y sus respectivos hpp):

	1.	CalcFunctions.cpp 				iguales
	2.	Fitness.cpp						iguales
	3.	Retina.cpp						iguales
	4.	RetinaFilter.cpp				iguales
	5.	SimFiles.cpp					iguales


Diferencias entre MODI_raw_F2 y MODI_retina_F2:

	1.	RIAR.cpp

		a)		Se crea un objeto del tipo Retina y se obtiene una imagen procesada por ese objeto para pasarlo como parámetro a la red de aprendizaje.

	2.	Champion.cpp

		a)		Se crea un objeto del tipo Retina y se obtiene una imagen procesada por ese objeto para pasarlo como parámetro a la red de aprendizaje.

-------------------------------------------------------------------------------------------------------------
Igualdades entre MODI_raw_F3 y MODI_retina_F3 (archivos cpp y sus respectivos hpp):

	1.	CalcFunctions.cpp 				iguales
	2.	Fitness.cpp						iguales
	3.	Retina.cpp						iguales
	4.	RetinaFilter.cpp				iguales
	5.	SimFiles.cpp					iguales


Diferencias entre MODI_raw_F2 y MODI_retina_F2:

	1.	RIAR.cpp

		a)		Se crea un objeto del tipo Retina y se obtiene una imagen procesada por ese objeto para pasarlo como parámetro a la red de aprendizaje.

	2.	Champion.cpp

		a)		Se crea un objeto del tipo Retina y se obtiene una imagen procesada por ese objeto para pasarlo como parámetro a la red de aprendizaje.





/**
*	@mainpage RIAR and Champion
*	@author Oscar Silva
*	@date Sep 30, 2016
*	@see Original repository: https://github.com/osilvam/Practica
*
	We  built  a  robot  able  to  navigate  autonomously  in  a  simulated  environment.
	To  process  visual  information  and  generate  the  corresponding  motor  actions,
	the  robot  relies  in  an  image  encoder  based  in  the  mammalian  retina.  For  this
	purpose,  the  encoder  was  used  as  an  input  for  an  evolving  neural  network  that
	was  trained  with  a  genetic  algorithm,  allowing  the  robot  to  learn  how  to  effi-
	ciently  avoid  objects.

	The  main  features  of  the  retina-inspired  encoder  are  a  Difference  of  Gaus-
	sians  (DoG)  spatial  filter  and  a  Difference  of  Exponentials  (DoE)  temporal
	filter,  to  mimic  the  ON-OFF  ganglion  cells  in  the  retina.  This  approach  allows
	the  detection  of  edges  and  movement  using  only  a  fraction  of  the  information
	contained  in  the  original  input  image 

	Patricio Cerda.
	Maria José Escobar.
	A. Palacios

	RIAR.cpp:

		Creates a NEAT training using a simulation of a robot in a maze with help of V-REP. In this case 
		the algorithm for computer vision is without the retina encoder.
		In the end of the entire simulations a champion file with its respective movement and velocity files
		are created so that the champion executable can be loaded.

	Champion.cpp:

		Program intended to run the champion simulation of the last training made. 
    	In order to use this program, the whole training must be completed.

    MODI_raw_F1:

		This experiment does not detect the collides made by the robot, but it does detect when it moves
		backwards. The experiment worries that the individual wheels of the robot change their
		velocity independently. The fitness is computed taking into account every distance covered between 
		measurements during the simulation. The raw input image is sent to NEAT.

	MODI_raw_F2:

		This experiment detects collides made by the robot so that it can be taken into account by the
		fitness. It also detects when the robot moves backwards. The experiment worries that the 
		individual wheels of the robot change their	velocity independently. The fitness is computed taking 
		into account every distance covered between measurements during the simulation. The raw input image is sent to NEAT.

	MODI_raw_F3:

		This experiment does not detect the collides made by the robot and it does not mind if the robot is moving backwards
		or not, but it does mind the change in movement direction instead of the changes in the speed of the wheels
		themselves. This experiment computes the fitness in terms of how much distance it covers between the initial
		measurement and the last one in the entire simulation. The raw input image is sent to NEAT.

	MODI_retina_F1:

		This experiment does not detect the collides made by the robot, but it does detect when it moves
		backwards. The experiment worries that the individual wheels of the robot change their
		velocity independently. The fitness is computed taking into account every distance covered between 
		measurements during the simulation. The input image is processed by the Retina encoder before going to NEAT.

	MODI_retina_F2:

		This experiment detects collides made by the robot so that it can be taken into account by the
		fitness. It also detects when the robot moves backwards. The experiment worries that the 
		individual wheels of the robot change their	velocity independently. The fitness is computed taking 
		into account every distance covered between measurements during the simulation. The input image is processed 
		by the Retina encoder before going to NEAT.

	MODI_retina_F3:

		This experiment does not detect the collides made by the robot and it does not mind if the robot is moving backwards
		or not, but it does mind the change in movement direction instead of the changes in the speed of the wheels
		themselves. This experiment computes the fitness in terms of how much distance it covers between the initial
		measurement and the last one in the entire simulation. The input image is processed 
		by the Retina encoder before going to NEAT.

*/
		